# TSP に対する 2-opt 法

- TSP に対する 2-opt 法を numpy を使って書いた。
- TODO
    - 隣接行列を使う場合。
    - networkx のアルゴリズムを使う場合。
    - iterated local search にする場合。

```py
import numpy as np
import random

DEBUG = True


def get_total_cost(route):
    total_cost = dist[route[-1], route[0]]
    for i in range(len(route)-1):
        total_cost += dist[route[i], route[i+1]]
    return total_cost


def two_opt(dist, initial_route):
    route = initial_route.copy()

    if DEBUG:
        print(f'initial route: {route}')
        print(f'initial cost: {get_total_cost(route)}')
    
    while True:

        # 近傍操作
        improved = False

        # 順列から2つの辺を順番に選択する
        indices_i = list(range(len(route)-2))
        random.shuffle(indices_i)
        for i in indices_i:
            i0 = route[i]
            i1 = route[i+1]

            indices_j = list(range(i+2, len(route)))
            random.shuffle(indices_j)
            for j in indices_j:
                j0 = route[j]
                j1 = route[j+1] if j+1 != len(route) else route[0]
                
                # 更新前の距離
                d0 = dist[i0, i1]
                d1 = dist[j0, j1]

                # 更新後の距離
                e0 = dist[i0, j0]
                e1 = dist[i1, j1]
                
                # 改善解を発見したら順路を更新する
                if d0 + d1 > e0 + e1:
                    improved = True

                    # 順路更新
                    new_route = route[i+1:j+1]
                    route[i+1:j+1] = new_route[::-1]
                    
                    if DEBUG:
                        print(f'--' * 20)

                        print(f'found two edges ({i0}, {i1}) and ({j0}, {j1})')
                        print(f'distance between city {route[i0]} and city {route[i1]} is {d0}')
                        print(f'distance between city {route[j0]} and city {route[j1]} is {d1}')
                        print(f'distance between city {route[i0]} and city {route[j0]} is {e0}')
                        print(f'distance between city {route[i1]} and city {route[j1]} is {e1}')

                        print(f'cost diff {(e0 + e1) - (d0 + d1)}')
                        print(f'new route {route}')
                        print(f'new cost {get_total_cost(route)}')

                    break

            if improved:
                break

        # 改善解が存在しないなら終了する
        if not improved:
            break

    return route


# 都市数
n = 10

# 対称な距離行列
dist = np.random.randint(low=1, high=10, size=(n, n))
dist = np.tril(dist, k=-1) + np.tril(dist, k=-1).T

# 初期解
initial_route = np.arange(n)

route = two_opt(dist, initial_route)
print(route)
```